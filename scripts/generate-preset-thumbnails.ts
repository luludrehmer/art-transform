#!/usr/bin/env tsx
/**
 * Generates preset thumbnail images for the style picker (Portrait mood cards).
 * Uses Gemini API directly (standalone). Run: npm run generate-preset-thumbnails
 *
 * Output: client/src/assets/preset_thumbnails/{none,intelligent,neoclassical,royal_noble,heritage}.png
 * Then auto-generates client/src/lib/preset-images.ts so the build picks them up.
 */

import { writeFile, mkdir, access } from "fs/promises";
import { dirname, join } from "path";
import { fileURLToPath } from "url";
import { generatePresetThumbnailImage, PRESET_IDS } from "../server/generate-gallery";

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT = join(__dirname, "..");

const OUTPUT_DIR = join(ROOT, "client", "src", "assets", "preset_thumbnails");
const PRESET_IMAGES_PATH = join(ROOT, "client", "src", "lib", "preset-images.ts");
const DELAY_BETWEEN_REQUESTS_MS = 2000;
const MAX_RETRIES = 2;

function extractBase64FromDataUrl(dataUrl: string): Buffer {
  const match = dataUrl.match(/^data:image\/\w+;base64,(.+)$/);
  if (!match) {
    throw new Error("Invalid data URL format");
  }
  return Buffer.from(match[1], "base64");
}

async function main() {
  console.log("Preset thumbnail generation (Gemini API, standalone)");
  console.log("Output:", OUTPUT_DIR);
  console.log("Presets:", PRESET_IDS.join(", "));
  console.log("");

  await mkdir(OUTPUT_DIR, { recursive: true });

  const succeeded: string[] = [];

  for (const presetId of PRESET_IDS) {
    const outputPath = join(OUTPUT_DIR, `${presetId}.png`);
    let lastErr: Error | null = null;
    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
      try {
        console.log(`Generating ${presetId}.png${attempt > 1 ? ` (retry ${attempt}/${MAX_RETRIES})` : ""}...`);
        const imageUrl = await generatePresetThumbnailImage(presetId);
        const buffer = extractBase64FromDataUrl(imageUrl);
        await writeFile(outputPath, buffer);
        console.log(`  OK`);
        succeeded.push(presetId);
        lastErr = null;
        break;
      } catch (err) {
        lastErr = err instanceof Error ? err : new Error(String(err));
        const msg = lastErr.message;
        console.error(`  ${attempt < MAX_RETRIES ? "Retrying" : "FAILED"}:`, msg);
        if (attempt < MAX_RETRIES) {
          await new Promise((r) => setTimeout(r, DELAY_BETWEEN_REQUESTS_MS));
        } else {
          process.exitCode = 1;
        }
      }
    }

    if (presetId !== PRESET_IDS[PRESET_IDS.length - 1]) {
      await new Promise((r) => setTimeout(r, DELAY_BETWEEN_REQUESTS_MS));
    }
  }

  console.log("");
  console.log(`Done. ${succeeded.length} images written, ${PRESET_IDS.length - succeeded.length} failed.`);

  // Generate preset-images.ts for every preset that has a PNG on disk
  const toExport = succeeded.length > 0 ? succeeded : (await existingPresetPngs()).filter((id) => PRESET_IDS.includes(id));
  if (toExport.length === 0) {
    console.log("No preset images to export. Skipping preset-images.ts.");
    return;
  }

  const lines: string[] = [
    'import type { StylePresetId } from "@/lib/style-presets";',
    "",
    "// Auto-generated by scripts/generate-preset-thumbnails.ts",
    "",
  ];

  for (const id of toExport) {
    const varName = id.replace(/-/g, "_");
    lines.push(`import ${varName} from "@/assets/preset_thumbnails/${id}.png";`);
  }

  lines.push("");
  lines.push("export const STYLE_PRESET_IMAGES: Partial<Record<StylePresetId, string>> = {");
  for (const id of toExport) {
    const varName = id.replace(/-/g, "_");
    lines.push(`  "${id}": ${varName},`);
  }
  lines.push("};");

  await writeFile(PRESET_IMAGES_PATH, lines.join("\n"));
  console.log(`Generated ${PRESET_IMAGES_PATH} (${toExport.length} presets).`);
}

async function existingPresetPngs(): Promise<string[]> {
  const { readdir } = await import("fs/promises");
  const names = await readdir(OUTPUT_DIR).catch(() => []);
  return names.filter((n) => n.endsWith(".png")).map((n) => n.slice(0, -4));
}

main();
