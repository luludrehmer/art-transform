#!/usr/bin/env tsx
/**
 * Robust SEO metadata injector. Reads from JSON (generated by medusa-generate-seo).
 *
 * Features:
 *   - Concurrent requests (default 3 parallel)
 *   - Local progress file (.seo-inject-progress.json) — instant resume, no re-fetch
 *   - 30s timeout per request (shorter = fail fast)
 *   - Log every variant with timing
 *   - ETA calculation
 *   - Graceful Ctrl+C (saves progress before exit)
 *   - Exponential backoff on errors
 *
 * Run:
 *   npm run medusa-inject-seo-robust
 *   npm run medusa-inject-seo-robust -- --concurrency=5
 *   npm run medusa-inject-seo-robust -- --reset       (ignora progresso, recomeça)
 *   npm run medusa-inject-seo-robust -- --products-only
 *
 * Requires: MEDUSA_BACKEND_URL, MEDUSA_ADMIN_EMAIL, MEDUSA_ADMIN_PASSWORD in .env
 */

import "dotenv/config";
import fs from "fs";
import path from "path";

// ── Config ──────────────────────────────────────────────────────────
const BACKEND = process.env.MEDUSA_BACKEND_URL?.replace(/\/$/, "") || "";
const EMAIL = process.env.MEDUSA_ADMIN_EMAIL || "";
const PASSWORD = process.env.MEDUSA_ADMIN_PASSWORD || "";

const CONCURRENCY = parseInt(
  process.argv.find((a) => a.startsWith("--concurrency="))?.split("=")[1] || "3",
  10
);
const RESET = process.argv.includes("--reset");
const PRODUCTS_ONLY = process.argv.includes("--products-only");
const INPUT_FILE =
  process.argv.find((a) => a.startsWith("--file="))?.split("=")[1] ||
  "art-transform-seo-metadata.json";

const TIMEOUT_MS = 120_000; // 120s — Railway/Medusa is slow (~60s median per variant POST)
const MAX_RETRIES = 3;
const PROGRESS_FILE = ".seo-inject-progress.json";

// ── Types ───────────────────────────────────────────────────────────
interface SeoData {
  generatedAt: string;
  products: { id: string; handle: string; metadata: Record<string, string> }[];
  variants: {
    productId: string;
    variantId: string;
    sku: string;
    metadata: Record<string, unknown>;
  }[];
}

interface Progress {
  completedVariants: string[]; // variantIds
  failedVariants: string[];
  completedProducts: string[];
}

// ── Globals ─────────────────────────────────────────────────────────
let progress: Progress = { completedVariants: [], failedVariants: [], completedProducts: [] };
let shuttingDown = false;
let token = "";
const startTime = Date.now();

// ── Progress persistence ────────────────────────────────────────────
const progressPath = path.resolve(process.cwd(), PROGRESS_FILE);

function loadProgress(): void {
  if (RESET) {
    progress = { completedVariants: [], failedVariants: [], completedProducts: [] };
    return;
  }
  try {
    if (fs.existsSync(progressPath)) {
      progress = JSON.parse(fs.readFileSync(progressPath, "utf-8"));
      console.log(
        `  Loaded progress: ${progress.completedVariants.length} done, ${progress.failedVariants.length} failed, ${progress.completedProducts.length} products\n`
      );
    }
  } catch {
    progress = { completedVariants: [], failedVariants: [], completedProducts: [] };
  }
}

function saveProgress(): void {
  try {
    fs.writeFileSync(progressPath, JSON.stringify(progress, null, 2), "utf-8");
  } catch {
    // Ignore write errors during shutdown
  }
}

// ── Graceful shutdown ───────────────────────────────────────────────
process.on("SIGINT", () => {
  if (shuttingDown) process.exit(1);
  shuttingDown = true;
  console.log("\n\n⚠️  Ctrl+C — saving progress...");
  saveProgress();
  const done = progress.completedVariants.length;
  const failed = progress.failedVariants.length;
  console.log(`  Saved: ${done} done, ${failed} failed`);
  console.log(`  Resume: npm run medusa-inject-seo-robust\n`);
  process.exit(0);
});

// ── Auth ────────────────────────────────────────────────────────────
async function getToken(): Promise<string> {
  const res = await fetch(`${BACKEND}/auth/user/emailpass`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ email: EMAIL, password: PASSWORD }),
  });
  if (!res.ok) throw new Error(`Auth failed: ${res.status}`);
  return (await res.json()).token;
}

// ── HTTP with timeout ───────────────────────────────────────────────
async function httpPost(
  urlPath: string,
  body: object
): Promise<{ ok: boolean; status: number; error?: string }> {
  const url = `${BACKEND}${urlPath}`;
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), TIMEOUT_MS);
  try {
    const res = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify(body),
      signal: controller.signal,
    });
    clearTimeout(timer);
    // Drain body to free connection
    await res.text();
    if (res.ok) return { ok: true, status: res.status };
    return { ok: false, status: res.status, error: `HTTP ${res.status}` };
  } catch (err: any) {
    clearTimeout(timer);
    const msg = err.name === "AbortError" ? "timeout" : err.message || "unknown";
    return { ok: false, status: 0, error: msg };
  }
}

// ── Update one variant with retries ─────────────────────────────────
async function updateVariant(v: SeoData["variants"][0]): Promise<boolean> {
  const urlPath = `/admin/products/${v.productId}/variants/${v.variantId}`;
  for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
    if (shuttingDown) return false;
    const t0 = Date.now();
    const result = await httpPost(urlPath, { sku: v.sku, metadata: v.metadata });
    const ms = Date.now() - t0;
    if (result.ok) return true;
    if (attempt < MAX_RETRIES) {
      const wait = 2000 * attempt;
      console.log(
        `    ⚠ ${v.variantId} attempt ${attempt}/${MAX_RETRIES} failed (${result.error}, ${ms}ms) — retry in ${wait}ms`
      );
      await new Promise((r) => setTimeout(r, wait));
    } else {
      console.log(
        `    ✗ ${v.variantId} FAILED after ${MAX_RETRIES} attempts (${result.error}, ${ms}ms)`
      );
    }
  }
  return false;
}

// ── Concurrency pool ────────────────────────────────────────────────
async function processPool(
  items: SeoData["variants"][0][],
  concurrency: number,
  total: number,
  alreadyDone: number
): Promise<{ ok: number; fail: number }> {
  let ok = 0;
  let fail = 0;
  let idx = 0;
  let processed = 0;

  async function worker(): Promise<void> {
    while (idx < items.length && !shuttingDown) {
      const i = idx++;
      const v = items[i];
      const success = await updateVariant(v);
      processed++;
      const globalDone = alreadyDone + processed;
      if (success) {
        ok++;
        progress.completedVariants.push(v.variantId);
      } else {
        fail++;
        progress.failedVariants.push(v.variantId);
      }
      // Log every variant
      const elapsed = (Date.now() - startTime) / 1000;
      const rate = globalDone / elapsed;
      const remaining = total - globalDone;
      const eta = rate > 0 ? Math.round(remaining / rate) : "?";
      const pct = Math.round((globalDone / total) * 100);
      const symbol = success ? "✓" : "✗";
      console.log(
        `  ${symbol} [${globalDone}/${total}] ${pct}% | ok:${alreadyDone + ok} fail:${fail} | ${elapsed.toFixed(0)}s elapsed, ETA ${eta}s`
      );
      // Save progress every 10 variants
      if (processed % 10 === 0) saveProgress();
    }
  }

  const workers = Array.from({ length: Math.min(concurrency, items.length) }, () => worker());
  await Promise.all(workers);
  saveProgress();
  return { ok, fail };
}

// ── Format time ─────────────────────────────────────────────────────
function fmtTime(seconds: number): string {
  if (seconds < 60) return `${seconds}s`;
  const m = Math.floor(seconds / 60);
  const s = seconds % 60;
  return `${m}m${s}s`;
}

// ── Main ────────────────────────────────────────────────────────────
async function main() {
  if (!BACKEND || !EMAIL || !PASSWORD) {
    console.error("Set MEDUSA_BACKEND_URL, MEDUSA_ADMIN_EMAIL, MEDUSA_ADMIN_PASSWORD in .env");
    process.exit(1);
  }

  console.log("=== Medusa Inject SEO (Robust) ===");
  console.log(`Backend: ${BACKEND}`);
  console.log(`Concurrency: ${CONCURRENCY} | Timeout: ${TIMEOUT_MS / 1000}s | Max retries: ${MAX_RETRIES}`);
  console.log(`${RESET ? "RESET mode (ignoring progress)\n" : ""}`);

  // Load input data
  const inputPath = path.resolve(process.cwd(), INPUT_FILE);
  if (!fs.existsSync(inputPath)) {
    console.error(`File not found: ${inputPath}`);
    console.error("Run first: npm run medusa-generate-seo");
    process.exit(1);
  }
  const data: SeoData = JSON.parse(fs.readFileSync(inputPath, "utf-8"));
  console.log(`Input: ${data.products.length} products, ${data.variants.length} variants\n`);

  // Load progress
  loadProgress();

  // Auth
  console.log("Authenticating...");
  token = await getToken();
  console.log("OK\n");

  // Warm-up
  console.log("Warming up backend...");
  try {
    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), 60_000);
    await fetch(`${BACKEND}/admin/products?limit=1`, {
      headers: { Authorization: `Bearer ${token}` },
      signal: controller.signal,
    });
    clearTimeout(timer);
    console.log("Backend ready.\n");
  } catch (e) {
    console.warn("Warm-up slow, waiting 10s...");
    await new Promise((r) => setTimeout(r, 10_000));
    // Try once more
    try {
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), 60_000);
      await fetch(`${BACKEND}/admin/products?limit=1`, {
        headers: { Authorization: `Bearer ${token}` },
        signal: controller.signal,
      });
      clearTimeout(timer);
      console.log("Backend ready (2nd attempt).\n");
    } catch {
      console.warn("Backend might be slow. Proceeding anyway.\n");
    }
  }

  // ── Products ────────────────────────────────────────────────────
  const productsToUpdate = data.products.filter(
    (p) => !progress.completedProducts.includes(p.id)
  );
  if (productsToUpdate.length > 0) {
    console.log(`--- Products (${productsToUpdate.length}) ---`);
    for (const p of productsToUpdate) {
      if (shuttingDown) break;
      const result = await httpPost(`/admin/products/${p.id}`, { metadata: p.metadata });
      if (result.ok) {
        progress.completedProducts.push(p.id);
        console.log(`  ✅ ${p.handle}`);
      } else {
        // Retry once
        await new Promise((r) => setTimeout(r, 3000));
        const retry = await httpPost(`/admin/products/${p.id}`, { metadata: p.metadata });
        if (retry.ok) {
          progress.completedProducts.push(p.id);
          console.log(`  ✅ ${p.handle} (retry)`);
        } else {
          console.log(`  ❌ ${p.handle}: ${result.error}`);
        }
      }
    }
    saveProgress();
    console.log();
  } else {
    console.log("Products: all already done.\n");
  }

  if (PRODUCTS_ONLY) {
    console.log("=== Done (products only) ===");
    return;
  }

  // ── Variants ──────────────────────────────────────────────────
  const completedSet = new Set(progress.completedVariants);
  const failedSet = new Set(progress.failedVariants);
  // Retry previously failed ones too
  const toInject = data.variants.filter((v) => !completedSet.has(v.variantId));
  const totalTarget = data.variants.length;
  const alreadyDone = completedSet.size;

  if (toInject.length === 0) {
    console.log("Variants: all already done!");
    console.log(`\n=== Done === (${alreadyDone}/${totalTarget})`);
    return;
  }

  console.log(`--- Variants ---`);
  console.log(`  Total: ${totalTarget} | Already done: ${alreadyDone} | To inject: ${toInject.length}`);
  console.log(`  Concurrency: ${CONCURRENCY}\n`);

  const { ok, fail } = await processPool(toInject, CONCURRENCY, totalTarget, alreadyDone);

  const elapsed = Math.round((Date.now() - startTime) / 1000);
  console.log(`\n=== Done ===`);
  console.log(`  Variants: ${alreadyDone + ok} ok, ${fail} failed (of ${totalTarget})`);
  console.log(`  Time: ${fmtTime(elapsed)}`);
  if (fail > 0) {
    console.log(`  ${fail} failures saved. Retry: npm run medusa-inject-seo-robust`);
  }
}

main().catch((err) => {
  saveProgress();
  console.error(err);
  process.exit(1);
});
